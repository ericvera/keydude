const base64js = require('base64-js')
const LZString = require('lz-string')

// NOTE: Recomended IV size in 96 bits (find source). In the case of a Uint8Array that is 12 elements.
const IVSIZE = 12
// NOTE: Using AES-GCM as it is recommended for security and perf
// Reference: https://en.wikipedia.org/wiki/Galois/Counter_Mode
// Reference: https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/
const ALGORITHM = 'AES-GCM'
const DIGESTALGORITHM = 'SHA-256'
const LENGTHOFKEY = 256

/**
 * (Internal) Convests the provided string to an Uint8Array
 * @param {String} text
 * @returns {Uint8Array}
 */
const toUint8Array = text => {
  // Original from: http://qnimate.com/passphrase-based-encryption-using-web-cryptography-api/
  let array = new Uint8Array(text.length)
  for (let i = 0; i < text.length; i++) {
    array[i] = text.charCodeAt(i)
  }

  return array
}

/**
 * (Internal) Convests the provided Uint8Array to a string
 * @param {Uint8Array} uint8Array
 * @returns {String}
 */
const toString = uint8Array => {
  var str = ''
  for (var iii = 0; iii < uint8Array.byteLength; iii++) {
    str += String.fromCharCode(uint8Array[iii])
  }

  return str
}

/**
 * (Internal) Generate a wrap/unwrap key using the hash of the provided passphrase
 * @param {String} passphrase A text passphrase to hash in order to generate the key
 * @param {String} base64PassphraseIV A base64 initiation vector used to generate the key
 * @returns {Promise<CryptoKey>}
 */
const generateWrappingKey = async (passphrase, base64PassphraseIV) => {
  const passphraseBuffer = toUint8Array(passphrase)
  const passphraseIVByteArray = base64js.toByteArray(base64PassphraseIV)
  const algorithm = { name: ALGORITHM, iv: passphraseIVByteArray }

  const passphraseHash = await crypto.subtle.digest(
    DIGESTALGORITHM,
    passphraseBuffer
  )

  let wrappingKey

  wrappingKey = await crypto.subtle.importKey(
    'raw',
    passphraseHash,
    algorithm,
    false,
    ['wrapKey', 'unwrapKey']
  )

  return wrappingKey
}

/**
 * (Internal) Generate a secure 96-bit initialization vector in Uint8Array format
 * @returns {Promise<Uint8Array>}
 */
const generateRawIV = async () => {
  return Promise.resolve(crypto.getRandomValues(new Uint8Array(IVSIZE)))
}

//
// Public API begins here
//

/**
 * Generate a secure 96-bit initialization vector and returns it as a base64 encoded string.
 * @returns {Promise<String>} base64 encoded IV
 */
const generateIV = async () => {
  const iv = await generateRawIV()

  return Promise.resolve(base64js.fromByteArray(iv))
}

/**
 * Generates a new encryption/decryption key. You should use wrapKey before
 * storing the key anywhere and then unwrap key when you need to use it.
 * @returns {CryptoKey}
 */
const generateEncryptionDecryptionKey = async () => {
  // Generate a new key for encryption/decryption
  const newKey = await crypto.subtle.generateKey(
    { name: ALGORITHM, length: LENGTHOFKEY },
    true,
    ['encrypt', 'decrypt']
  )

  // Return the generated key
  return newKey
}

/**
 * Wrap (encode) the key using a key generated from the passphrase.
 * @param {String} passphrase passphrase used to generate the key used to wrap the provided key
 * @param {String} base64PassphraseIV base64 encoded initiation vector used to generate the wrapping key
 * @param {CryptoKey} keyToWrap key to wrap so that it can be stored
 * @returns {Promise<{k:String, iv: String}>} Both the returned key and iv are base64 encoded
 */
const wrapKey = async (passphrase, base64PassphraseIV, keyToWrap) => {
  const wrappingKey = await generateWrappingKey(passphrase, base64PassphraseIV)

  // Wrap the key
  const iv = await generateRawIV()
  const wrappingAlgorithm = { name: ALGORITHM, iv }
  const wrappedKey = await crypto.subtle.wrapKey(
    'raw',
    keyToWrap,
    wrappingKey,
    wrappingAlgorithm
  )

  const wrappedKeyString = base64js.fromByteArray(new Uint8Array(wrappedKey))
  const ivString = base64js.fromByteArray(iv)

  // Return the wrapped key in an object with strings so that
  // it can be easily stored in db
  return { k: wrappedKeyString, iv: ivString }
}

/**
 * Unwraps a previously wrapped key so that it can be used.
 * @param {String} passphrase passphrase used to generate the key used to unwrap the provided wrapped key
 * @param {String} base64PassphraseIV base64 encoded initiation vector used to generate the unwrapping key
 * @param {{k:String, iv: String}} wrappedKeyObject Object generated by wrapKey containing base64 encoded key (k) and iv
 * @returns {CryptoKey}
 */
const unwrapKey = async (passphrase, base64PassphraseIV, wrappedKeyObject) => {
  const unwrappingKey = await generateWrappingKey(
    passphrase,
    base64PassphraseIV
  )

  // Unwrap the key
  const iv = base64js.toByteArray(wrappedKeyObject.iv)
  const wrappedKey = base64js.toByteArray(wrappedKeyObject.k)
  const unwrappingAlgorithm = { name: ALGORITHM, iv }

  const unwrappedKey = await crypto.subtle.unwrapKey(
    'raw',
    wrappedKey,
    unwrappingKey,
    unwrappingAlgorithm,
    { name: ALGORITHM, length: LENGTHOFKEY },
    false,
    ['encrypt', 'decrypt']
  )

  // Return the wrapped key
  return unwrappedKey
}

/**
 * This will JSON.stringify, compress, and finally encrypt the provided object.
 * @param {Object} dataObject Object to be encrypted
 * @param {CryptoKey} encryptionDecryptionKey Key used to encrypt the object
 * @returns {Promise<{ed: String, iv: String}>} Object containing, base64 encoded, encrypted data (data) and iv
 */
const encrypt = async (dataObject, encryptionDecryptionKey) => {
  // Source : https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt

  // Generate a new IV
  const iv = await generateRawIV()

  // Stringify and compressthe dataObject
  const arrayBufferToEncrypt = LZString.compressToUint8Array(
    JSON.stringify(dataObject)
  )

  // Define algorithm
  // NOTE: Use AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv }

  // Encrypt
  const dataBuffer = await crypto.subtle.encrypt(
    algorithm,
    encryptionDecryptionKey,
    arrayBufferToEncrypt
  )

  // Convert to base64 for easy storage
  const dataString = base64js.fromByteArray(new Uint8Array(dataBuffer))
  const ivString = base64js.fromByteArray(iv)

  return { ed: dataString, iv: ivString }
}

/**
 * This will JSON.stringify, compress, and finally encrypt the provided object.
 * @param {Object} dataObject Object to be encrypted
 * @param {CryptoKey} encryptionDecryptionKey Key used to encrypt the object
 * @returns {Promise<{ed: String, iv: String}>} Object containing, base64 encoded, encrypted data (data) and iv
 */
const _encryptSingleStringIO = async (dataObject, encryptionDecryptionKey) => {
  // Source : https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt

  // Generate a new IV
  const iv = await generateRawIV()

  // Stringify and compressthe dataObject
  const arrayBufferToEncrypt = toUint8Array(JSON.stringify(dataObject))

  // Define algorithm
  // NOTE: Use AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv }

  // Encrypt
  const dataBuffer = await crypto.subtle.encrypt(
    algorithm,
    encryptionDecryptionKey,
    arrayBufferToEncrypt
  )

  // Convert to base64 for easy storage
  const dataArr = new Uint8Array(dataBuffer)
  const concatenatedArr = new Uint8Array(dataArr.length + iv.length)
  concatenatedArr.set(dataArr)
  concatenatedArr.set(iv, dataArr.length)

  const base64Data = base64js.fromByteArray(concatenatedArr)

  return base64Data
}

/**
 * This will JSON.stringify, compress, and finally encrypt the provided object.
 * @param {Object} dataObject Object to be encrypted
 * @param {CryptoKey} encryptionDecryptionKey Key used to encrypt the object
 * @returns {Promise<{ed: String, iv: String}>} Object containing, base64 encoded, encrypted data (data) and iv
 */
const _encryptConcatArrays = async (dataObject, encryptionDecryptionKey) => {
  // Source : https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt

  // Generate a new IV
  const iv = await generateRawIV()

  // Stringify and compressthe dataObject
  const arrayBufferToEncrypt = toUint8Array(JSON.stringify(dataObject))

  // Define algorithm
  // NOTE: Use AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv }

  // Encrypt
  const dataBuffer = await crypto.subtle.encrypt(
    algorithm,
    encryptionDecryptionKey,
    arrayBufferToEncrypt
  )

  // Convert to base64 for easy storage
  const dataArr = new Uint8Array(dataBuffer)
  const concatenatedArr = new Uint8Array(dataArr.length + iv.length)
  concatenatedArr.set(dataArr)
  concatenatedArr.set(iv, dataArr.length)

  const base64Data = base64js.fromByteArray(concatenatedArr)

  return base64Data
}

/**
 * This will JSON.stringify, compress, and finally encrypt the provided object.
 * @param {Object} dataObject Object to be encrypted
 * @param {CryptoKey} encryptionDecryptionKey Key used to encrypt the object
 * @returns {Promise<{ed: String, iv: String}>} Object containing, base64 encoded, encrypted data (data) and iv
 */
const _encryptWithoutCompression = async (
  dataObject,
  encryptionDecryptionKey
) => {
  // Source : https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt

  // Generate a new IV
  const iv = await generateRawIV()

  // Stringify and compressthe dataObject
  const arrayBufferToEncrypt = toUint8Array(JSON.stringify(dataObject))

  // Define algorithm
  // NOTE: Use AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv }

  // Encrypt
  const dataBuffer = await crypto.subtle.encrypt(
    algorithm,
    encryptionDecryptionKey,
    arrayBufferToEncrypt
  )

  // Convert to base64 for easy storage
  const dataString = base64js.fromByteArray(new Uint8Array(dataBuffer))
  const ivString = base64js.fromByteArray(iv)

  return { ed: dataString, iv: ivString }
}

/**
 * This will JSON.stringify, compress, and finally encrypt the provided object.
 * @param {Object} dataObject Object to be encrypted
 * @param {CryptoKey} encryptionDecryptionKey Key used to encrypt the object
 * @returns {Promise<{ed: String, iv: String}>} Object containing, base64 encoded, encrypted data (data) and iv
 */
const _encryptWithCompressionOnBase64 = async (
  dataObject,
  encryptionDecryptionKey
) => {
  // Source : https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt

  // Generate a new IV
  const iv = await generateRawIV()

  // Stringify and compressthe dataObject
  const arrayBufferToEncrypt = toUint8Array(JSON.stringify(dataObject))

  // Define algorithm
  // NOTE: Use AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv }

  // Encrypt
  const dataBuffer = await crypto.subtle.encrypt(
    algorithm,
    encryptionDecryptionKey,
    arrayBufferToEncrypt
  )

  // Convert to base64 for easy storage
  const dataString = LZString.compressToBase64(
    base64js.fromByteArray(new Uint8Array(dataBuffer))
  )
  const ivString = base64js.fromByteArray(iv)

  return { ed: dataString, iv: ivString }
}

/**
 * Call this on the result of an encrypt call in order to decrypt the object.
 * @param {{ed: String, iv: String}} encryptedDataObject Object containing, base64 encoded, encrypted data (data) and iv
 * @param {CryptoKey} encryptionDecryptionKey Key used to decrypt the object
 * @returns {Object} Decrypted object (decompressed and JSON.parse called to reverse encrypt process)
 */
const decrypt = async (encryptedDataObject, encryptionDecryptionKey) => {
  // Source: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt

  // Convert the data from base64 to byte array
  const encryptedData = base64js.toByteArray(encryptedDataObject.ed)
  const encryptedDataIv = base64js.toByteArray(encryptedDataObject.iv)

  // Define algorithm
  // NOTE: User AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv: encryptedDataIv }

  // Decrypt
  const decryptedData = await crypto.subtle.decrypt(
    algorithm,
    encryptionDecryptionKey,
    encryptedData
  )

  // Convert to string
  const decryptedStringifiedObject = LZString.decompressFromUint8Array(
    new Uint8Array(decryptedData)
  )

  // Convert from stringified back to JSON object
  const decryptedObject = JSON.parse(decryptedStringifiedObject)

  // Return decrypted object
  return decryptedObject
}

/**
 * Call this on the result of an encrypt call in order to decrypt the object.
 * @param {{ed: String, iv: String}} encryptedDataObject Object containing, base64 encoded, encrypted data (data) and iv
 * @param {CryptoKey} encryptionDecryptionKey Key used to decrypt the object
 * @returns {Object} Decrypted object (decompressed and JSON.parse called to reverse encrypt process)
 */
const _decryptWithoutCompression = async (
  encryptedDataObject,
  encryptionDecryptionKey
) => {
  // Source: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt

  // Convert the data from base64 to byte array
  const encryptedData = base64js.toByteArray(encryptedDataObject.ed)
  const encryptedDataIv = base64js.toByteArray(encryptedDataObject.iv)

  // Define algorithm
  // NOTE: User AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv: encryptedDataIv }

  // Decrypt
  const decryptedData = await crypto.subtle.decrypt(
    algorithm,
    encryptionDecryptionKey,
    encryptedData
  )

  // Convert to string
  //TODO: TEST encrypt/decrypt without compression
  const decryptedStringifiedObject = toString(new Uint8Array(decryptedData))

  // Convert from stringified back to JSON object
  const decryptedObject = JSON.parse(decryptedStringifiedObject)

  // Return decrypted object
  return decryptedObject
}

/**
 * Call this on the result of an encrypt call in order to decrypt the object.
 * @param {{ed: String, iv: String}} encryptedDataObject Object containing, base64 encoded, encrypted data (data) and iv
 * @param {CryptoKey} encryptionDecryptionKey Key used to decrypt the object
 * @returns {Object} Decrypted object (decompressed and JSON.parse called to reverse encrypt process)
 */
const _decryptWithCompressionOnBase64 = async (
  encryptedDataObject,
  encryptionDecryptionKey
) => {
  // Source: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt

  // Convert the data from base64 to byte array
  const encryptedData = base64js.toByteArray(
    LZString.decompressFromBase64(encryptedDataObject.ed)
  )
  const encryptedDataIv = base64js.toByteArray(encryptedDataObject.iv)

  // Define algorithm
  // NOTE: User AES-GCM based on recommendations at https://en.wikipedia.org/wiki/Galois/Counter_Mode
  const algorithm = { name: ALGORITHM, iv: encryptedDataIv }

  // Decrypt
  const decryptedData = await crypto.subtle.decrypt(
    algorithm,
    encryptionDecryptionKey,
    encryptedData
  )

  // Convert to string
  //TODO: TEST encrypt/decrypt without compression
  const decryptedStringifiedObject = toString(new Uint8Array(decryptedData))

  // Convert from stringified back to JSON object
  const decryptedObject = JSON.parse(decryptedStringifiedObject)

  // Return decrypted object
  return decryptedObject
}

module.exports = {
  encrypt,
  _encryptWithCompressionOnBase64,
  _encryptWithoutCompression,
  _encryptSingleStringIO,
  _encryptConcatArrays,
  decrypt,
  generateIV,
  generateEncryptionDecryptionKey,
  wrapKey,
  unwrapKey
}
